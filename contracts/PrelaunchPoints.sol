// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";

contract PrelaunchPoints is Ownable {
    mapping(address => uint256) public points;
    mapping(address => bool) public hasStaked;
    bytes32 public referralCode;

    event PointsAdded(address indexed user, uint256 points, bytes32 referralCode);

    // Constructor passing initial owner address to Ownable
    constructor(address initialOwner) Ownable(initialOwner) {
        referralCode = keccak256(abi.encodePacked("VALID_REFERRAL"));
    }

    // Function to stake ETH and earn points with referral code
    function stakeETH(bytes32 _referralCode) external payable {
        require(msg.value > 0, "Must stake ETH");

        if (_referralCode == referralCode) {
            points[msg.sender] += msg.value * 2; // bonus points for referral
        } else {
            points[msg.sender] += msg.value;
        }

        hasStaked[msg.sender] = true;
        emit PointsAdded(msg.sender, points[msg.sender], _referralCode);
    }

    // Function to withdraw ETH based on points
    function withdraw() external {
        require(hasStaked[msg.sender], "No points to withdraw");
        uint256 userPoints = points[msg.sender];
        require(userPoints > 0, "No points available");

        payable(msg.sender).transfer(userPoints);
        points[msg.sender] = 0;
    }
}
